shellac
-------
:language: python

+shellac+ is an extension of the standard python library http://docs.python.org/3/library/cmd.html[cmd], which aims to offer an alternative approach to nesting commands to that currently offered by +cmd+

In +cmd+, the command-line entered is assumed to be a single +command+ followed by a string containing +arguments+ to that command.  This makes it difficult to call strings of nested commands without using operating in a modal manner, where each command is its own class inheriting from Cmd.

+shellac+ is different.  It supports nested commands by evaluating for you whether the items provided on the command-line are commands, sub-commands or arguments.  It allows you to flexibly build a hierarchy to your own specification, without needing to have a complex understanding of the innards of either +shellac+ or +cmd+.

With +shellac+

[source, shell]
(Cmd) alpha bravo charlie

Could be configured to be any of:

* Command: +alpha+, Arguments: +bravo charlie+
* Command: +alpha bravo+, Arguments: +charlie+
* Command: +alpha bravo charlie+ (no Arguments)

+shellac+ supports full tab-completion, by default returning all the sub-commands of the 'current' command.  However it also extends this to allow tab-completion based on your own functions.  This allows you to tab-complete from queries to data sources, command-line tools or other python data structures simply by specifying a function which will perform this query and return a list of possible completions.

Using +shellac+
~~~~~~~~~~~~~~~

TIP: Since shellac is derived from +cmd+ you can override many of the public instance variables such as +prompt+, +intro+ etc.  You probably also want to consider overriding the +emptyline+ method.  See http://docs.python.org/3/library/cmd.html#cmd.Cmd.prompt[cmd] for details.


Simple Commands
^^^^^^^^^^^^^^^

You should begin by importing the module:

[source]
import shellac

This will give you access to the main +shellac.Shellac+ class, which you will need to override with your own class, as well as some helper functions.

You can now construct the nested hierarchy which contains the commands and sub-commands for your program.  These must begin with +do_+ (to be distinguished from other non-hierarchy objects in your class).

If you wish to create a commands in your hierarchy that will contain other commands, it should be created as a +class+.  For commands which will actually do something, it is best to create +methods+ (or classes with a +__call__+ method defined).  It is not possible to have a command that both runs (with arguments) and also has nested sub-commands.

Callable commands will be passed +args+ which contains all text following them on the command-line.

For example, we want a program with 2 top-level commands, +user+ and +exit+.  +user+ will hold sub-commands, so is a +class+ but +exit+ will be run and so is a +method+:


[source]
--------------------------------------------------------------
import shellac
import sys

class myShellac(shellac.Shellac):

    class do_user():
        pass

    class do_group():
        pass

    def do_exit(self, args):
        return
    do_EOF = do_exit()

if __name__ == "__main__":
    if len(sys.argv) > 1:
        myShellac().onecmd(' '.join(sys.argv[1:]))
    else:
        myShellac().cmdloop()

--------------------------------------------------------------

You should see tab-completion working when you run this command.  Additionally, the +do_exit+ function is mapped to +do_EOF+, so ctrl-D will also cause the program to exit.

The extra code at the end will look for any arguments passed to the script when run from the command-line, and if presented inside the command shell.


Sub-Commands
^^^^^^^^^^^^

Now we want to add some sub-commands to our do_user class:

[source]
--------------------------------------------------------------

class myShellac(shellac.Shellac):

    class do_user():
        def do_add(self, args):
            print("Added user " + args)

        def do_remove(self, args):
            print("Removed user " + args)

    class do_group():
        pass
--------------------------------------------------------------

Now run it:

[source, shell]
(Cmd) user add foo
Added user foo+


Extended Completions
^^^^^^^^^^^^^^^^^^^^

Up until now, completion has simply shown a list of all sub-commands (nested classes/methods) of the current command.

In this example, for the +remove+ function, we want to tab-complete from the list of existing users in our imaginary user database.  Let us assume that we have a function called +list_users+ which will query our database and return a list of user accounts (for now we will simply return a static list):

[source]
--------------------------------------------------------------

def list_users(token):
    return ['alice', 'bob', clive']

#   return shellac.complete_list(['alice', 'bob', 'clive'], token)

--------------------------------------------------------------

We'll put this at the top of our example code, but it could of course be imported from another module.

In the comment you can see the use of the +complete_list+ helper function from shellac.  This provides some quick short-hand to wrap a list and only return items from it which start with the +token+ (that you are tab-completing on).  Of course, if your +list_users+ module was capable of filtering the results it returned, you could use +token+ to filter and only return an appropriate list.

+shellac+ offers a +@completer+ decorator to specify external function(s) which should be called to complete for a particular method.  You can specify as many of these as you like, and the lists returned by each function called will be joined together before being presented as complete options.

[source]
--------------------------------------------------------------

    class do_user():

        ...

        @shellac.completer(list_users)
        do_remove(self, args):
            print("Removed user " + args)

--------------------------------------------------------------

Now if we run it we can see it completing from the list_users function:

[source]
--------------------------------------------------------------
(Cmd) user remove <Tab>
alice bob clive

(Cmd) user remove a<Tab>
alice

--------------------------------------------------------------


Corner Cases
^^^^^^^^^^^^

It is important to note that although you are handed back a list of completions, you can opt to type any text, and this will be used as commands or arguments, which may or may not be valid.

Consider for example:

[source]
---------------------------------------------------------
def greetings(token):
    return ["good"]

def compliments(token):
    return ["pretty", "clever"]

def insults(token):
    return ["ugly", "stupid"]

class myShellac(shellac.Shellac):

    @shellac.completer(greetings)
    class do_greet():
        @shellac.completer(compliments)
        def do_good(self, args):
            print("You are " + args)
        @shellac.completer(insults)
        def do_bad(self, args):
            print("You are " + args)
---------------------------------------------------------

Lets try running this code:

[source,shell]
(Cmd) greet <Tab>
good

Since the list returned by the +greetings+ function doesn't include it, we don't find out about the +bad+ function:

[source, shell]
(Cmd) greet good <Tab>
clever pretty

We then choose one of these compliments and all is good:

[source, shell]
(Cmd) greet good pretty
You are pretty

How lovely!

However, we could opt to ignore the argument completions, and be a bit ruder:

[source, shell]
(Cmd) greet good horrible
You are horrible

Not very nice at all!

Now, although our +greetings+ function only offers +good+ greetings on tab-completion, there is a 'hidden' +bad+ greeting with associated insults:

[source, shell]
(Cmd) greet bad <Tab>
stupid ugly

However, we can still choose to ignore these completions, and put in something nicer manually:

[source, shell]
(Cmd) greet bad wonderful
You are wonderful

An awkward situation averted!

While this (mis)use might appear to be quite confusing to anyone actually running this particular code, it does allow flexibility: both accepting arguments other than those suggested by the completion function; and having 'hidden' commands which aren't suggested by the completion function.

Addendum
^^^^^^^^

For the sake of clarity/completeness, if you wanted to be able to use both +compliments+ and +insults+ functions, then you'd just discard one level of the whole hierarchy and apply two decorators:

[source]
--------------------------------------------------
def compliments(token):
    return ["pretty", "clever"]

def insults(token):
    return ["ugly", "stupid"]

class myShellac(shellac.Shellac):

    @shellac.completer(compliments)
    @shellac.completer(insults)
    def do_greet(self, args):
            print("You are " + args)

--------------------------------------------------

Resulting in:

[source, shell]
(Cmd) greet <Tab>
clever pretty stupid ugly

